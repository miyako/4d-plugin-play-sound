/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Sound.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Sound
 #	author : miyako
 #	2021/01/08
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Sound.h"

#pragma mark -

#if VERSIONWIN
#pragma comment(lib, "winmm.lib")
#include <tchar.h> //for _stprintf_s
#else
#include <mutex>
#import <Cocoa/Cocoa.h>
#import <Foundation/Foundation.h>
namespace sound {
NSMutableDictionary *aliases = nil;
std::mutex mutex;
}
#endif

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
#if VERSIONMAC
        case kInitPlugin :
        case kServerInitPlugin :
            sound::aliases = [[NSMutableDictionary alloc]init];
            break;
            
        case kDeinitPlugin :
        case kServerDeinitPlugin :
            [sound::aliases release];
            break;
#endif
			// --- Sound
            
			case 1 :
				process_sound_file(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -
#if VERSIONWIN
static const wchar_t *getCommandStringForAction(sound_action_t action) {

    switch (action) {
        case sound_action_pause:
            return L"pause \"%s\" wait";
            break;
        case sound_action_play:
            return L"play \"%s\"";
            break;
        case sound_action_resume:
            return L"resume \"%s\" wait";
            break;
        case sound_action_open:
            return L"open \"%s\" alias \"%s\" wait";
            break;
        case sound_action_stop:
            return L"stop \"%s\" wait";
            break;
        case sound_action_close:
            return L"close \"%s\" wait";
            break;
        default:
            return L"";
            break;
    }
}
#endif

#if VERSIONMAC
static void removeAliasKey(NSString *alias){
    
    std::lock_guard<std::mutex> lock(sound::mutex);
    
    NSSound *sound = [sound::aliases valueForKey:alias];
    if(sound){
        [sound stop];
        [sound release];
        [sound::aliases removeObjectForKey:alias];
    }
}
static NSString *selectorForAction(sound_action_t action) {
    switch (action) {
        case sound_action_pause:
            return @"pause";
            break;
        case sound_action_play:
            return @"play";
            break;
        case sound_action_stop:
            return @"stop";
            break;
        case sound_action_resume:
            return @"resume";
            break;
        default:
            return @"";
            break;
    }
}
static void performSelectorForAction(C_TEXT& Param1, sound_action_t action){
    
    NSString *alias = Param1.copyUTF16String();
    NSSound *sound = [sound::aliases valueForKey:alias];
    if(sound){
        [sound performSelector:NSSelectorFromString(selectorForAction(action))];
    }
    [alias release];
}
#endif

#if VERSIONWIN
static void sendCommand(wchar_t *commandString, C_TEXT& returnValue){
    wchar_t errorText[128] = {0};
    MCIERROR errorCode = mciSendString(commandString, NULL, 0, NULL);
    if(mciGetErrorString(errorCode, errorText, 128)){
        CUTF16String err = CUTF16String((PA_Unichar *)errorText);
        returnValue.setUTF16String(&err);
    }
}
#endif

void process_sound_file(PA_PluginParameters params) {

    C_TEXT Param1;
    C_TEXT returnValue;

    PackagePtr pParams = (PackagePtr)params->fParameters;
    Param1.fromParamAtIndex(pParams, 1);
    
    sound_action_t action = (sound_action_t)PA_GetLongParameter(params, 2);
    
#if VERSIONWIN
    wchar_t commandString[_MAX_PATH + 128] = {0};
    wchar_t *alias = (wchar_t *)Param1.getUTF16StringPtr();
    _stprintf_s(commandString, getCommandStringForAction(action), alias, alias);
    sendCommand(commandString, returnValue);
#else
    switch (action) {
        case sound_action_open:
        {
            NSURL *url = Param1.copyUrl();
            if(url){
                NSString *alias = Param1.copyUTF16String();
                removeAliasKey(alias);
                NSSound* sound = [[NSSound alloc]initWithContentsOfURL:url byReference:YES];
                [sound::aliases setValue:sound forKey:alias];
                [url release];
                [alias release];
            }
        }
            break;
        case sound_action_pause:
        case sound_action_play:
        case sound_action_stop:
        case sound_action_resume:
            performSelectorForAction(Param1, action);
            break;
        case sound_action_close:
        {
            NSString *alias = Param1.copyUTF16String();
            removeAliasKey(alias);
            [alias release];
        }
             break;
        case sound_duration:
            {
                NSString *alias = Param1.copyUTF16String();
                NSSound *sound = [sound::aliases valueForKey:alias];
                if(sound){
                    returnValue.setUTF16String([[NSNumber numberWithDouble:[sound duration]]stringValue]);
                }
                [alias release];
            }
            break;
        case sound_is_playing:
        {
            NSString *alias = Param1.copyUTF16String();
            NSSound *sound = [sound::aliases valueForKey:alias];
            if(sound){
                returnValue.setUTF16String([sound isPlaying] ? @"YES" : @"NO");
            }
            [alias release];
        }
            break;
    }
#endif
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    returnValue.setReturn(pResult);
}
